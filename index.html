<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pose Match – MediaPipe (Face + Hand)</title>
  <style>
    :root {
      --bg: #0b1120;
      --panel: #0f172a;
      --border: rgba(148, 163, 184, 0.35);
      --accent: #22c55e;
      --muted: #94a3b8;
      --text: #e2e8f0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1f2937, #0b1120 55%, #020617 100%);
      color: var(--text);
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 24px;
    }
    .shell {
      width: 100%;
      max-width: 1200px;
      background: linear-gradient(145deg, #0b1224, #090f1e);
      border: 1px solid var(--border);
      border-radius: 26px;
      padding: 20px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: relative;
      overflow: hidden;
    }
    .header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .title {
      font-size: 1.5rem;
      font-weight: 700;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .pill {
      padding: 4px 10px;
      border: 1px solid var(--border);
      border-radius: 999px;
      color: var(--muted);
      font-size: 0.8rem;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .dot { width: 8px; height: 8px; border-radius: 50%; background: #fbbf24; box-shadow: 0 0 10px rgba(234,179,8,0.9); }
    .pill.ready .dot { background: var(--accent); box-shadow: 0 0 10px rgba(34,197,94,0.9); }
    .pill strong { color: var(--text); }
    .subtitle { color: var(--muted); max-width: 640px; }
    .layout { display: grid; grid-template-columns: 1.05fr 1.5fr; gap: 16px; }
    @media (max-width: 900px) { .layout { grid-template-columns: 1fr; } body { padding: 14px; } }
    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 14px;
      position: relative;
      overflow: hidden;
    }
    .panel h3 {
      margin: 0 0 10px;
      font-size: 0.9rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .ref-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 10px;
    }
    @media (max-width: 600px) { .ref-grid { grid-template-columns: 1fr; } }
    .card {
      border: 1px solid rgba(148,163,184,0.4);
      border-radius: 12px;
      background: #0b1223;
      overflow: hidden;
      transition: 0.2s ease;
      position: relative;
    }
    .card img {
      display: block;
      width: 100%;
      aspect-ratio: 4/3;
      object-fit: cover;
    }
    .card .meta {
      padding: 8px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text);
      font-weight: 600;
      font-size: 0.9rem;
    }
    .tag {
      border: 1px solid rgba(148,163,184,0.5);
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.7rem;
      color: var(--muted);
    }
    .card.active {
      border-color: var(--accent);
      box-shadow: 0 10px 30px rgba(34,197,94,0.25);
      transform: translateY(-2px);
    }
    .metrics {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 8px;
      font-size: 0.78rem;
    }
    .metric {
      border: 1px solid rgba(148,163,184,0.35);
      border-radius: 999px;
      padding: 6px 10px;
      display: flex;
      justify-content: space-between;
      color: var(--muted);
      background: rgba(15,23,42,0.7);
    }
    .metric.good { color: #4ade80; }
    .metric.bad { color: #fca5a5; }
    .video-wrap {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(148,163,184,0.35);
      aspect-ratio: 4 / 3;
      background: #000;
    }
    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    canvas { pointer-events: none; }
    .pose-label {
      position: absolute;
      left: 12px;
      bottom: 12px;
      padding: 8px 12px;
      background: rgba(15,23,42,0.9);
      border: 1px solid var(--border);
      border-radius: 999px;
      color: var(--muted);
      display: inline-flex;
      gap: 8px;
      align-items: center;
      opacity: 0;
      transform: translateY(8px);
      transition: 0.2s ease;
      backdrop-filter: blur(12px);
    }
    .pose-label.visible { opacity: 1; transform: translateY(0); }
    .pose-label.active { border-color: var(--accent); color: #d1fae5; }
    .error {
      position: absolute;
      inset: 0;
      background: rgba(15,23,42,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      text-align: center;
      color: #fca5a5;
      font-weight: 600;
    }
    .hint {
      position: absolute;
      right: 10px;
      bottom: 10px;
      font-size: 0.75rem;
      color: var(--muted);
      background: rgba(15,23,42,0.85);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 5px 10px;
      backdrop-filter: blur(10px);
    }
  </style>
</head>
<body>
  <main class="shell">
    <div class="header">
      <div>
        <div class="title">Pose Match <span class="pill ready" id="status-pill"><span class="dot"></span><span id="status-text"><strong>Initializing</strong> • allow camera</span></span></div>
        <div class="subtitle">Mimic the reference poses. MediaPipe FaceLandmarker + GestureRecognizer run in real-time. Press Space to pause/resume.</div>
      </div>
    </div>

    <div class="layout">
      <section class="panel">
        <h3>Reference</h3>
        <div class="ref-grid">
          <article class="card" data-pose="peace">
            <img src="hamster_peace.jpg" alt="Hamster peace sign">
            <div class="meta"><span>Peace Sign</span><span class="tag">Gesture</span></div>
          </article>
          <article class="card" data-pose="scared">
            <img src="hamster_scared.jpg" alt="Hamster scared">
            <div class="meta"><span>Scared</span><span class="tag">Mouth</span></div>
          </article>
          <article class="card" data-pose="tongue">
            <img src="cat_tongue.jpg" alt="Cat tongue out">
            <div class="meta"><span>Tongue Out</span><span class="tag">Mouth + Eyes</span></div>
          </article>
          <article class="card" data-pose="big_eyes">
            <img src="cat_eyes.jpg" alt="Cat big eyes">
            <div class="meta"><span>Big Eyes</span><span class="tag">Eyes</span></div>
          </article>
        </div>
        <div class="metrics">
          <div class="metric" id="metric-mar"><span>MAR</span><span class="value">–</span></div>
          <div class="metric" id="metric-ear"><span>EAR</span><span class="value">–</span></div>
          <div class="metric" id="metric-gesture"><span>HAND</span><span class="value">–</span></div>
        </div>
      </section>

      <section class="panel">
        <h3>Live Camera</h3>
        <div class="video-wrap">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
          <div class="pose-label" id="pose-label"><span id="pose-label-text">Looking for pose…</span></div>
          <div class="error" id="error-box">Camera or model error. Check permissions or reload.</div>
          <div class="hint">Space — Pause/Resume</div>
        </div>
      </section>
    </div>
  </main>

  <script type="module">
    import { FaceLandmarker, FilesetResolver, DrawingUtils, GestureRecognizer } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14";

    const video = document.getElementById("video");
    const overlay = document.getElementById("overlay");
    const ctx = overlay.getContext("2d");
    const cards = [...document.querySelectorAll(".card")];
    const poseLabel = document.getElementById("pose-label");
    const poseLabelText = document.getElementById("pose-label-text");
    const statusPill = document.getElementById("status-pill");
    const statusText = document.getElementById("status-text");
    const errorBox = document.getElementById("error-box");
    const metricMAR = document.getElementById("metric-mar");
    const metricEAR = document.getElementById("metric-ear");
    const metricGesture = document.getElementById("metric-gesture");

    let faceLandmarker, gestureRecognizer;
    let running = true;
    let rafId = null;
    let lastVideoTime = -1;

    const MAR_SCARED = 0.65;
    const MAR_TONGUE_MIN = 0.32;
    const MAR_TONGUE_MAX = 0.6;
    const EAR_BIG_EYES = 0.33;
    const EAR_EYES_CLOSED = 0.2;

    function setStatus(text, ready = false) {
      statusText.innerHTML = text;
      statusPill.classList.toggle("ready", ready);
      const dot = statusPill.querySelector(".dot");
      dot.style.background = ready ? "#22c55e" : "#fbbf24";
      dot.style.boxShadow = ready ? "0 0 10px rgba(34,197,94,0.9)" : "0 0 10px rgba(234,179,8,0.9)";
    }

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function computeMAR(landmarks) {
      const top = landmarks[13], bottom = landmarks[14], left = landmarks[78], right = landmarks[308];
      if (!top || !bottom || !left || !right) return null;
      const v = distance(top, bottom);
      const h = distance(left, right);
      return h === 0 ? null : v / h;
    }

    function computeEAR(landmarks) {
      const L_top = landmarks[159], L_bottom = landmarks[145], L_left = landmarks[33], L_right = landmarks[133];
      const R_top = landmarks[386], R_bottom = landmarks[374], R_left = landmarks[362], R_right = landmarks[263];
      if (!L_top || !L_bottom || !L_left || !L_right || !R_top || !R_bottom || !R_left || !R_right) return null;
      const earL = distance(L_top, L_bottom) / distance(L_left, L_right);
      const earR = distance(R_top, R_bottom) / distance(R_left, R_right);
      return (earL + earR) / 2;
    }

    function updateMetric(el, value, { goodRange, badRange } = {}) {
      const v = el.querySelector(".value");
      v.textContent = value == null ? "–" : value.toFixed(3);
      el.classList.remove("good", "bad");
      if (value == null) return;
      if (goodRange && value >= goodRange[0] && value <= goodRange[1]) el.classList.add("good");
      if (badRange && (value < badRange[0] || value > badRange[1])) el.classList.add("bad");
    }

    function updateGesture(text) {
      const v = metricGesture.querySelector(".value");
      v.textContent = text || "–";
      metricGesture.classList.remove("good", "bad");
      if (text === "Peace/Victory") metricGesture.classList.add("good");
    }

    function highlightPose(pose) {
      cards.forEach(c => c.classList.toggle("active", c.dataset.pose === pose));
      if (!pose) {
        poseLabel.classList.remove("visible", "active");
        poseLabelText.textContent = "Looking for pose…";
        return;
      }
      const map = {
        peace: "Peace sign detected",
        scared: "Scared (mouth wide)",
        tongue: "Tongue-out pose",
        big_eyes: "Big eyes detected",
      };
      poseLabelText.textContent = map[pose] || pose;
      poseLabel.classList.add("visible", "active");
    }

    function decidePose({ mar, ear, gesture }) {
      const isPeace = gesture && ["victory", "peace"].some(g => gesture.toLowerCase().includes(g));
      if (isPeace) return "peace";
      if (mar != null && mar > MAR_SCARED) return "scared";
      if (mar != null && ear != null && mar >= MAR_TONGUE_MIN && mar <= MAR_TONGUE_MAX && ear < EAR_EYES_CLOSED) return "tongue";
      if (ear != null && ear > EAR_BIG_EYES) return "big_eyes";
      return null;
    }

    async function init() {
      try {
        setStatus("<strong>Starting camera…</strong>");
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal: 960 }, height: { ideal: 720 } }, audio: false });
        video.srcObject = stream;
        await video.play();

        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;

        const resolver = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");

        faceLandmarker = await FaceLandmarker.createFromOptions(resolver, {
          baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task" },
          runningMode: "VIDEO",
          numFaces: 1,
        });

        gestureRecognizer = await GestureRecognizer.createFromOptions(resolver, {
          baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task" },
          runningMode: "VIDEO",
          numHands: 2,
        });

        setStatus("<strong>Live</strong> • mimic a pose or press Space to pause", true);
        startLoop();
      } catch (err) {
        console.error(err);
        errorBox.style.display = "flex";
        setStatus("<strong>Error</strong> • check camera & reload", false);
      }
    }

    function startLoop() {
      const utils = new DrawingUtils(ctx);
      const loop = async () => {
        if (!running) { rafId = requestAnimationFrame(loop); return; }
        if (video.currentTime === lastVideoTime) { rafId = requestAnimationFrame(loop); return; }
        lastVideoTime = video.currentTime;

        const ts = performance.now();
        ctx.clearRect(0, 0, overlay.width, overlay.height);

        let mar = null, ear = null, gesture = null;

        const face = faceLandmarker?.detectForVideo(video, ts);
        if (face?.faceLandmarks?.length) {
          const lms = face.faceLandmarks[0];
          utils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: "#6366f1", lineWidth: 0.6 });
          utils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_FACE_OVAL, { color: "#22d3ee", lineWidth: 1.4 });
          utils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LIPS, { color: "#fb7185", lineWidth: 1.4 });
          utils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_LEFT_EYE, { color: "#a855f7", lineWidth: 1.4 });
          utils.drawConnectors(lms, FaceLandmarker.FACE_LANDMARKS_RIGHT_EYE, { color: "#a855f7", lineWidth: 1.4 });
          mar = computeMAR(lms);
          ear = computeEAR(lms);
        }

        const hands = gestureRecognizer?.recognizeForVideo(video, ts);
        if (hands?.gestures?.length) {
          const top = hands.gestures[0][0];
          gesture = top?.categoryName || null;
          if (hands.landmarks) {
            hands.landmarks.forEach(lm => {
              utils.drawConnectors(lm, GestureRecognizer.HAND_CONNECTIONS, { color: "#fb923c", lineWidth: 3 });
              utils.drawLandmarks(lm, { color: "#fed7aa", lineWidth: 1, radius: 2 });
            });
          }
        }

        updateMetric(metricMAR, mar, { badRange: [0, 0.28] });
        updateMetric(metricEAR, ear, { badRange: [0, 0.18] });
        updateGesture(gesture ? (gesture === "Victory" ? "Peace/Victory" : gesture) : "None");

        const pose = decidePose({ mar, ear, gesture });
        highlightPose(pose);

        rafId = requestAnimationFrame(loop);
      };
      rafId = requestAnimationFrame(loop);
    }

    window.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        running = !running;
        if (running) setStatus("<strong>Live</strong> • mimic a pose or press Space to pause", true);
        else { setStatus("<strong>Paused</strong> • press Space to resume", false); highlightPose(null); }
      }
    });

    window.addEventListener("beforeunload", () => {
      if (rafId) cancelAnimationFrame(rafId);
      if (faceLandmarker) faceLandmarker.close();
      if (gestureRecognizer) gestureRecognizer.close();
      if (video.srcObject) video.srcObject.getTracks().forEach(t => t.stop());
    });

    init();
  </script>
</body>
</html>
